\chapter{Setup}

During the setup phase, the election authority will initialize the contents of
three tables. This will be followed by an audit, to ensure honesty of the
election authority. The three tables which are initialized are referred to as
the \textbf{P}, \textbf{D} and \textbf{R} tables:
\begin{description}
\item[\emph{P}rint table] Contains all information which is required to print
the ballots, along with information for auditing purposes.
\item[\emph{D}ecryption table] Contains all information required to decrypt the
voter's encrypted vote in the tally phase, along with information for auditing
purposes.
\item[\emph{R}esults table] Contains outcome of election.
\end{description}

For the following, we will assume an election with one question, answer
possibilities $a$ and $b$, voted on by $n$ voters.

\section{Election authority in a threshold setting}

For the purpose of this chapter we assume the election authority to be a single entity, in full possession of their private keys. In a real-life deployment it would be prudent to utilize some form of threshold cryptography to spread the trust across multiple parties.

\section{Initializing the \textbf{P} table}

The election authority first populates $2n$ rows of the \emph{P} table as shown
in table \ref{tbl:p_table_full}. This table is indexed by a primary key $ID_P$,
corresponding to the ballot ID which will be printed on both pages of the
ballot. It then picks two random permutations \ptop{} and \pbottom{},
corresponding to the permutations of the top and bottom pages respectively.
Permutations will be shown explicitly. In an actual implementation they might
however be chosen as shown in section \ref{sec:generating_permutations}.

For each row it then calculates two cryptographic commitments, \ctop{} and
\cbottom{}, to \ptop{} and \pbottom{} respectively.

\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		$ID_P$ & \ptop & \pbottom & $Choice$ & \ctop & \cbottom \\
		\hline
		1 & ab & ab & & $C_{1, 1}$ & $C_{1, 2}$ \\
		2 & ab & ba & & $C_{2, 1}$ & $C_{2, 2}$ \\
		3 & ba & ab & & $C_{3, 1}$ & $C_{3, 2}$ \\
		4 & ba & ba & & $C_{4, 1}$ & $C_{4, 2}$ \\
		5 & ab & ba & & $C_{5, 1}$ & $C_{5, 2}$ \\
		6 & ba & ab & & $C_{6, 1}$ & $C_{6, 2}$ \\
		\hline
	\end{tabular}
	\label{tbl:p_table_full}
	\caption{Print table}
\end{table}

\section{Initializing the \textbf{D} table}

The election authority then populates $2n$ rows of the \emph{D} table as per
table \ref{tbl:d_table_full}. This table contains a reference to the \emph{P}
table by means of the $ID_P$ column, and to the \emph{R} table by means of the
$ID_R$ column. Both $ID_P$ and $ID_R$ are random and independent permutations
of the elements $1, 2, \ldots, 2n$. It then chooses \pone{} randomly, and
calculates \ptwo{} such that $\ptwo \circ \pone \circ \pbottom \circ \ptop =
id$ yields the identity permutation. To achieve a concise notation,
$\rightarrow$ stands for the identity permutation over two elements, while
$\circlearrowright$ stands for the permutation flipping the two elements.

The $\hat{R}$ column is left empty during the setup phase. As a last step a
cryptographic commitment $Com_i$ to each row is generated, as well as two
commitments to the $ID_P$ and \pone{}, respectively to the $ID_R$ and \ptwo{}
columns.

\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		$ID_P$ & $\pi_1$ & $\hat{R}$ & $\pi_2$ & $ID_R$ & $Com_{i}$ \\
		\hline
		6 & $\rightarrow$       & & $\circlearrowright$ & 5 & $C_6$ \\
		5 & $\circlearrowright$ & & $\rightarrow$       & 4 & $C_5$ \\
		2 & $\circlearrowright$ & & $\rightarrow$       & 1 & $C_2$ \\
		1 & $\circlearrowright$ & & $\circlearrowright$ & 3 & $C_1$ \\
		4 & $\rightarrow$       & & $\rightarrow$       & 2 & $C_4$ \\
		3 & $\rightarrow$       & & $\circlearrowright$ & 6 & $C_3$ \\
		\hline
		\multicolumn{2}{|c|}{$Com_{ID_P, \pi_1}$} &   & \multicolumn{2}{c|}{$Com_{\pi_2, ID_R}$} & \\
		\hline
	\end{tabular}
	\caption{Decryption table. $ID_P$ and $ID_R$ reference \emph{P} and \emph{R} tables respectively.}
	\label{tbl:d_table_full}
\end{table}

\section{Initializing the \textbf{R} table}

In a last step the election authority initializes $2n$ empty rows of the
\emph{R} table as shown in table \ref{tbl:r_table_full}.

\begin{table}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		$ID_R$ & $R$ \\
		\hline
		1 & \\
		2 & \\
		3 & \\
		4 & \\
		5 & \\
		6 & \\
		\hline
	\end{tabular}
	\caption{Results table.}
	\label{tbl:r_table_full}
\end{table}

\section{Setup audit}

The final phase of the setup consists of a first audit, by a set of trusted
auditors. The election authority starts by revealing a subset of the generated
tables, consisting of the primary ballot ID $ID_P$ in the \emph{P} table, and
the row commitments in the \emph{D} table, as show in table
\ref{tbl:setup_audit}. The auditor then gets to pick $n$ rows at random, for
which the election authority will reveal the full contents. After the reveal
the table thus looks like \ref{tbl:setup_audit_revealed}. The auditor will then
verify that all row commitments hold, and that $\ptwo \circ \pone \circ
\pbottom \circ \ptop = id$ holds.

Thus for every row where the election authority cheats there is a chance of
$\frac{1}{2}$ of it being caught. For the generalized case where the election
authority cheats on $f$ out of $n$ ballots, $k$ of which are audited, the
introductory paper\autocite{fisherPunchscanIntroductionSystem2006} provides an
upper bound of the election authority not being
caught of:
\[
	[(1 - \frac{k}{n})^f, (1 - \frac{f}{n})^k]
\]

\begin{table}
	\centering
	\begin{subtable}{.5\linewidth}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			$ID_P$ & $\pi_{t}$ & $\pi_{b}$ & $c$ & $Com_{\pi_{t}}$ & $Com_{\pi_{b}}$ \\
			\hline
			1 & & & & $C_{1, 1}$ & $C_{1, 2}$ \\
			2 & & & & $C_{2, 1}$ & $C_{2, 2}$ \\
			3 & & & & $C_{3, 1}$ & $C_{3, 2}$ \\
			4 & & & & $C_{4, 1}$ & $C_{4, 2}$ \\
			5 & & & & $C_{5, 1}$ & $C_{5, 2}$ \\
			6 & & & & $C_{6, 1}$ & $C_{6, 2}$ \\
			\hline
		\end{tabular}
	\end{subtable}%
	\begin{subtable}{.5\linewidth}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			$ID_P$ & $\pi_1$ & $\hat{R}$ & $\pi_2$ & $ID_R$ & $Com_{i}$ \\
			\hline
			& & & & & $C_6$ \\
			& & & & & $C_5$ \\
			& & & & & $C_2$ \\
			& & & & & $C_1$ \\
			& & & & & $C_4$ \\
			& & & & & $C_3$ \\
			\hline
			\multicolumn{2}{|c|}{$Com_{ID_P, \pi_1}$} &   & \multicolumn{2}{c|}{$Com_{\pi_2, ID_R}$} & \\
			\hline
		\end{tabular}
	\end{subtable}
	\caption{Subset of tables released for auditing purposes}
	\label{tbl:setup_audit}
\end{table}

\begin{table}
	\centering
	\begin{subtable}{.5\linewidth}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			$ID_P$ & $\pi_{t}$ & $\pi_{b}$ & $c$ & $Com_{\pi_{t}}$ & $Com_{\pi_{b}}$ \\
			\hline
			1 & & & & $C_{1, 1}$ & $C_{1, 2}$ \\
			2 & ab & ba & & $C_{2, 1}$ & $C_{2, 2}$ \\
			3 & & & & $C_{3, 1}$ & $C_{3, 2}$ \\
			4 & ba & ba & & $C_{4, 1}$ & $C_{4, 2}$ \\
			5 & ab & ba & & $C_{5, 1}$ & $C_{5, 2}$ \\
			6 & & & & $C_{6, 1}$ & $C_{6, 2}$ \\
			\hline
		\end{tabular}
	\end{subtable}%
	\begin{subtable}{.5\linewidth}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			$ID_P$ & $\pi_1$ & $\hat{R}$ & $\pi_2$ & $ID_R$ & $Com_{i}$ \\
			\hline
			&                     & &                     &   & $C_6$ \\
			5 & $\circlearrowright$ & & $\rightarrow$       & 4 & $C_5$ \\
			2 & $\circlearrowright$ & & $\rightarrow$       & 1 & $C_2$ \\
			&                     & &                     &   & $C_1$ \\
			4 & $\rightarrow$       & & $\rightarrow$       & 2 & $C_4$ \\
			&                     & &                     &   & $C_3$ \\
			\hline
			\multicolumn{2}{|c|}{$Com_{ID_P, \pi_1}$} &   & \multicolumn{2}{c|}{$Com_{\pi_2, ID_R}$} & \\
			\hline
		\end{tabular}
	\end{subtable}
	\caption{Subset of tables released for auditing purposes}
	\label{tbl:setup_audit_revealed}
\end{table}

\section{Generating permutations}
\label{sec:generating_permutations}

Implementations of Punchscan must be able to generate permutations in such a
way that three properties hold:
\begin{itemize}
	\item Observing parts of a permutation must give an attacker no useful information about the rest of the permutation.
	\item A compact representation must exist, such that it can be stored in a database.
	\item Permutations must be generated computationally, in a way that all
		members of the election authority trust the process.
\end{itemize}

The introductory paper outlines two ways by which such permutations can be
constructed in section 8 \autocite{fisherPunchscanIntroductionSystem2006}. The
first, shown in section \ref{sec:permutations_via_symmetric_cipher} is used to
permute the rows of the $D$ and $R$ tables. The second, shown in section
\ref{sec:permutations_via_shifts} is used to permute the top and bottom pages
of the ballot.

\subsection{Generate permutation over $n$ elements using a symmetric cipher}
\label{sec:permutations_via_symmetric_cipher}

Agree on a symmetric cipher and key $K$. Start with a table with two columns.
Initialize the first column to values $1, 2, \ldots, n$. Fill the second column
with $Enc_K(1), Enc_K(2), \ldots, Enc_K(n)$, where $Enc_K(i)$ is the result of
encrypting $i$ with key $K$ --- using a standard padding scheme if required.
Sort the table by the second column using some canonical ordering. Then, the
order of the numbers in the first column defines a permutation.

\subsection{Generate permutation over $n$ elements as combination of two cyclic shifts}
\label{sec:permutations_via_shifts}

For the $\pi_1, \pi_2, \pi_{top}, \pi_{bottom}$ permutations the authors note
that a simpler consruction is sufficient to generate all possible mappings
between answer possibilities and symbols. They propose to generate two random
numbers, and cyclically shift the list of answer possibilities by one of the
random numbers, and the list of answer symbols by the other.

This will clearly not generate all possible permutations of answer choices to symbols, but...
% TODO but what? :)

