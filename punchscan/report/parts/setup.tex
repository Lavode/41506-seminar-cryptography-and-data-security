\chapter{Setup}

During the setup phase, the election authority will initialize the contents of
three tables. This will be followed by an audit, to ensure honesty of the
election authority. The three tables which are initialized are referred to as
the \textbf{P}, \textbf{D} and \textbf{R} tables:
\begin{description}
\item[\emph{P}rint table] Contains all information which is required to print
the ballots, along with information for auditing purposes.
\item[\emph{D}ecryption table] Contains all information required to decrypt the
voter's encrypted vote in the tally phase, along with information for auditing
purposes.
\item[\emph{R}esults table] Contains outcome of election.
\end{description}

For the following, we will assume an election with one question, answer
possibilities $a$ and $b$, voted on by $n$ voters.

\section{Election authority in a threshold setting}

For the purpose of this chapter we assume the election authority to be a single entity, in full possession of their private keys. In a real-life deployment it would be prudent to utilize some form of threshold cryptography to spread the trust across multiple parties.

\section{Initializing the \textbf{P} table}

The election authority first populates $2n$ rows of the \emph{P} table as shown
in table \ref{tbl:p_table_full}. This table is indexed by a primary key $ID_P$,
corresponding to the ballot ID which will be printed on both pages of the
ballot. It then picks two random permutations \ptop{} and \pbottom{},
corresponding to the permutations of the top and bottom pages respectively.
Permutations will be shown explicitly. In an actual implementation they might
however be chosen as shown in section \ref{sec:generating_permutations}.

For each row it then calculates two cryptographic commitments, \ctop{} and
\cbottom{}, to \ptop{} and \pbottom{} respectively.

\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		$ID_P$ & \ptop & \pbottom & $Choice$ & \ctop & \cbottom \\
		\hline
		1 & ab & ab & & $C_{1, 1}$ & $C_{1, 2}$ \\
		2 & ab & ba & & $C_{2, 1}$ & $C_{2, 2}$ \\
		3 & ba & ab & & $C_{3, 1}$ & $C_{3, 2}$ \\
		4 & ba & ba & & $C_{4, 1}$ & $C_{4, 2}$ \\
		5 & ab & ba & & $C_{5, 1}$ & $C_{5, 2}$ \\
		6 & ba & ab & & $C_{6, 1}$ & $C_{6, 2}$ \\
		\hline
	\end{tabular}
	\label{tbl:p_table_full}
	\caption{Print table}
\end{table}

\section{Initializing the \textbf{D} table}

The election authority then populates $2n$ rows of the \emph{D} table as per
table \ref{tbl:d_table_full}. This table contains a reference to the \emph{P}
table by means of the $ID_P$ column, and to the \emph{R} table by means of the
$ID_$ column. Both $ID_P$ and $ID_R$ are random and independent permutations of
the elements $1, 2, \ldots, 2n$.

The election authority then chooses $\pone$ randomly, and calculates $\ptwo$
such that $\ptop \circ \pbottom \circ \pone \circ \ptwo = id$ yields the
identity permutation.

% TODO left off, elaborate on:
% - Commitment
% - R-hat
% then on R table

\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		$ID_P$ & $\pi_1$ & $\hat{R}$ & $\pi_2$ & $ID_R$ & $Com_{i}$ \\
		\hline
		6 & $\rightarrow$       & & $\circlearrowright$ & 5 & $C_6$ \\
		5 & $\circlearrowright$ & & $\rightarrow$       & 4 & $C_5$ \\
		2 & $\circlearrowright$ & & $\rightarrow$       & 1 & $C_2$ \\
		1 & $\circlearrowright$ & & $\circlearrowright$ & 3 & $C_1$ \\
		4 & $\rightarrow$       & & $\rightarrow$       & 2 & $C_4$ \\
		3 & $\rightarrow$       & & $\circlearrowright$ & 6 & $C_3$ \\
		\hline
		\multicolumn{2}{|c|}{$Com_{ID_P, \pi_1}$} &   & \multicolumn{2}{c|}{$Com_{\pi_2, ID_R}$} & \\
		\hline
	\end{tabular}
	\caption{Decryption table. $ID_P$ and $ID_R$ reference \emph{P} and \emph{R} tables respectively.}
	\label{tbl:d_table_full}
\end{table}

\section{Generating permutations}
\label{sec:generating_permutations}

Implementations of Punchscan must be able to generate permutations in such a
way that three properties hold:
\begin{itemize}
	\item Observing parts of a permutation must give an attacker no useful information about the rest of the permutation.
	\item A compact representation must exist, such that it can be stored in a database.
	\item Permutations must be generated computationally, in a way that all
		members of the election authority trust the process.
\end{itemize}

The introductory paper outlines two ways by which such permutations can be
constructed in section 8 \autocite{fisherPunchscanIntroductionSystem2006}. The
first, shown in section \ref{sec:permutations_via_symmetric_cipher} is used to
permute the rows of the $D$ and $R$ tables. The second, shown in section
\ref{sec:permutations_via_shifts} is used to permute the top and bottom pages
of the ballot.

\subsection{Generate permutation over $n$ elements using a symmetric cipher}
\label{sec:permutations_via_symmetric_cipher}

Agree on a symmetric cipher and key $K$. Start with a table with two columns.
Initialize the first column to values $1, 2, \ldots, n$. Fill the second column
with $Enc_K(1), Enc_K(2), \ldots, Enc_K(n)$, where $Enc_K(i)$ is the result of
encrypting $i$ with key $K$ --- using a standard padding scheme if required.
Sort the table by the second column using some canonical ordering. Then, the
order of the numbers in the first column defines a permutation.

\subsection{Generate permutation over $n$ elements as combination of two cyclic shifts}
\label{sec:permutations_via_shifts}

For the $\pi_1, \pi_2, \pi_{top}, \pi_{bottom}$ permutations the authors note
that a simpler consruction is sufficient to generate all possible mappings
between answer possibilities and symbols. They propose to generate two random
numbers, and cyclically shift the list of answer possibilities by one of the
random numbers, and the list of answer symbols by the other.

This will clearly not generate all possible permutations of answer choices to symbols, but...
% TODO but what? :)

